CSE-506 (Fall 2015)
Homework Assignment #2
KUMAR SASMIT 
(SBU ID: 110308698)
ksasmit@cs.stonybrook.edu
NOV - 08 - 2015


Purpose:
----------
To make a stackable file system on Linux file system to add anti-malware support to detect and prevent, 
virus patterns in files. anti-malware file system has been named amfs.  Amfs detects and prevents 
attempts to read or write bad files.  A "bad file" is defined as one that contains at least one known 
malware (e.g., virus) pattern.  Amfs is based on wrapfs whose source code is in fs/wrapfs.


Files added/changed:
----------------------
location:/usr/src/hw2-ksasmit/fs/amfs/*

amfsctl.h  
amfs.sh  
file.c     
main.c    
mmap.c
amfsctl.c 
amfs.h  
dentry.c  
inode.c  
lookup.c
super.c
Makefile


Constraints:
----------------
virus pattern can be at max 255 characters long.
When a pattern is removed from the database, the files marked bad for the pattern earlier remains quarantined.


To compile and install:
------------------------
There are two modules:
1>
amfs: anti-malware file system.
to compile and install:(all to be done inside fs/amfs/ with the included make file )
make //make file is included 
insmod amfs.ko
*Amfs takes a mount time argument to pass the name of the pattern file,
mkdir /mnt/amfs
# mount -t amfs -o pattdb=/mypatterns.db /some/lower/path /mnt/amfs
for example:
mount -t amfs -o pattdb=/usr/src/hw2-ksasmit/mypatterns.db /usr/src/mounted_dir /mnt/amfs
for removing the module:
umount /mnt/amfs
rmmod amfs.ko

2>
amfsctl : This runs on user side taking user commends for adding, removing and showing pattern from the pattern database.
to compile: gcc  amfsctl.c -o amfsctl //make opertaion done above will build amfsctl by default

1. To list patterns from database file on the user side
$ ./amfsctl -l /mnt/amfs

2. To add a new pattern
$ ./amfsctl -a "newpatt" /mnt/amfs

3. To remove an old pattern
$ ./amfsctl -r "oldpatt" /mnt/amfs

4. To get help about options
$ ./amfsctl -h


Implementation Details:
-------------------------
Amfs is a stackeble file system which works like an intermediate between VFS and lower file system.Amfs uses that private field to store several pieces of information, especially a pointer to the corresponding lower level file system's object
The connections between some objects in Amfs and their corresponding objects in the stacked-on file system, as well as the regular connections between the objects within the same layer is shown below
						F-->D-->I  (upper amfs)
						|   |   |				
						F-->D-->I	(lower fs)
When a file system operation in Amfs is called, it finds the corresponding lower level's object from the current one, and repeats the same operation on the lower object.
When Amfs is mounted with a dirctory path(can be a peripheral usb device too), the target mount path and the pattern database
file path is taken from the user.The pattern file is scanned and all the patterns are maintained in a linked list on the kernel side.
Any read/write/list etc request for the mounted volume goes through amfs. For read operation the file is scanned for a bad pattern, if found,
the read operation is blocked, and the file is marked quarantined - any further r/w operation on quarantined files are not permitted any more.
For write operation the user buffer is checked against bad pattern list for malware, if found the operation is blocked. 
also , the quarantined files are not listed in their directory. 
	Virus pattern can be updated with add/remove and list by the user through ioctl call through amfsctl which are received on the kernel side,
followed by updation of bad pattern list and the virus database file with the change. The complpete list of all virus pattern can be printed on 
the user side anytime through amfsctl ioctl list call. All the allocated memory are freed when the volume is unmounted


Reference:
------------
http://wrapfs.filesystems.org/docs/linux-stacking/node2.html
http://lxr.fsl.cs.sunysb.edu/linux/source/
http://lxr.free-electrons.com/
